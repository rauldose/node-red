@* ============================================================
   SOURCE: packages/node_modules/@node-red/editor-client/src/js/red.js
   SOURCE: packages/node_modules/@node-red/editor-client/src/js/main.js
   ============================================================
   ORIGINAL CODE (red.js lines 931-956):
   ------------------------------------------------------------
   function init(options) {
       if (initialised) {
           throw new Error("RED already initialised");
       }
       initialised = true;
       if(window.ace) { window.ace.require("ace/ext/language_tools"); }
       options = options || {};
       options.apiRootUrl = options.apiRootUrl || "";
       if (options.apiRootUrl && !/\/$/.test(options.apiRootUrl)) {
           options.apiRootUrl = options.apiRootUrl+"/";
       }
       options.target = $("#red-ui-editor");
       options.target.addClass("red-ui-editor");

       buildEditor(options);

       RED.i18n.init(options, function() {
           RED.settings.init(options, function() {
               if (knownThemes) {
                   RED.settings.editorTheme = RED.settings.editorTheme || {};
                   RED.settings.editorTheme.themes = knownThemes;
               }
               loadEditor();
           });
       })
   }
   ------------------------------------------------------------
   TRANSLATION:
   This Blazor component translates the RED.init() and buildEditor() functions.
   - jQuery DOM manipulation → Blazor component rendering
   - $.getJSON() → HttpClient with async/await
   - Event subscriptions → Component lifecycle events
   ============================================================ *@

@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@using NodeRed.Editor.Services
@inject EditorState State
@inject IEditorComms Comms
@inject HttpClient Http
@inject IJSRuntime JS
@inject Keyboard KeyboardService
@inject History HistoryService
@inject Clipboard ClipboardService
@inject Actions ActionsService
@implements IAsyncDisposable

<div id="red-ui-editor" class="red-ui-editor" @onkeydown="HandleKeyDown" @onkeydown:preventDefault="@_preventKeyDefault" tabindex="0">
    @* Header *@
    <div id="red-ui-header">
        <span class="red-ui-header-logo">
            @if (!string.IsNullOrEmpty(State.Theme?.Header?.Image))
            {
                <a href="@(State.Theme?.Header?.Url ?? "#")">
                    <img src="@State.Theme.Header.Image" alt="Logo" />
                    @if (!string.IsNullOrEmpty(State.Theme?.Header?.Title))
                    {
                        <span>@State.Theme.Header.Title</span>
                    }
                </a>
            }
            else
            {
                <span>Node-RED.NET</span>
            }
        </span>
        <ul class="red-ui-header-toolbar @(IsLoading ? "hide" : "")">
            @* Connected users indicator - translated from multiplayer.js *@
            <li style="margin-right: 8px;">
                <Multiplayer Enabled="@_multiplayerEnabled" ConnectedUsers="@_connectedUsers" />
            </li>
            @* Deploy button - translated from ui/deploy.js *@
            <li>
                <DeployButton OnDeploy="HandleDeploy" />
            </li>
            @* Menu button - translated from main.js buildMainMenu() *@
            <li style="position: relative;">
                <a id="red-ui-header-button-sidemenu" class="button" @onclick="ToggleMenu" @onclick:stopPropagation="true">
                    <i class="fa fa-bars"></i>
                </a>
                @* Dropdown menu - translated from main.js sidemenu *@
                @if (_menuOpen)
                {
                    <div class="red-ui-menu" style="position: absolute; right: 0; top: 100%; min-width: 200px; background: #444; border: 1px solid #333; box-shadow: 0 2px 8px rgba(0,0,0,0.3); z-index: 1000;">
                        <ul style="list-style: none; margin: 0; padding: 0;">
                            <li class="red-ui-menu-item" style="padding: 8px 12px; cursor: pointer; color: #ddd; border-bottom: 1px solid #555;" @onclick="() => { userSettingsRef?.Show(); _menuOpen = false; }">
                                <i class="fa fa-cog" style="width: 20px;"></i> Settings
                            </li>
                            <li class="red-ui-menu-item" style="padding: 8px 12px; cursor: pointer; color: #ddd; border-bottom: 1px solid #555;" @onclick="() => { paletteEditorRef?.Show(); _menuOpen = false; }">
                                <i class="fa fa-cubes" style="width: 20px;"></i> Manage palette
                            </li>
                            <li class="red-ui-menu-item" style="padding: 8px 12px; cursor: pointer; color: #ddd; border-bottom: 1px solid #555;" @onclick="() => { searchRef?.Show(); _menuOpen = false; }">
                                <i class="fa fa-search" style="width: 20px;"></i> Search flows
                            </li>
                            <li class="red-ui-menu-item" style="padding: 8px 12px; cursor: pointer; color: #ddd; border-bottom: 1px solid #555;" @onclick="() => { actionListRef?.Show(); _menuOpen = false; }">
                                <i class="fa fa-keyboard-o" style="width: 20px;"></i> Keyboard shortcuts
                            </li>
                            <li class="red-ui-menu-item" style="padding: 8px 12px; cursor: pointer; color: #ddd;" @onclick="() => ToggleSidebar()">
                                <i class="fa fa-columns" style="width: 20px;"></i> @(SidebarClosed ? "Show sidebar" : "Hide sidebar")
                            </li>
                        </ul>
                    </div>
                }
            </li>
        </ul>
        <div id="red-ui-header-shade" class="@(ShowHeaderShade ? "" : "hide")"></div>
    </div>

    @* Main container - translated from buildEditor() *@
    <div id="red-ui-main-container" class="@(SidebarClosed ? "red-ui-sidebar-closed" : "") @(IsLoading ? "hide" : "")">
        @* Loading progress - translated from loader object *@
        @if (IsLoading)
        {
            <Loader Progress="@LoadingProgress" Message="@LoadingMessage" />
        }

        @* Palette panel *@
        <div class="red-ui-palette-wrapper" style="position: absolute; top: 0; bottom: 0; left: 0; width: @(PaletteWidth)px; z-index: 10;">
            <Palette @ref="paletteRef" />
        </div>

        @* Palette separator/handle - translated from palette resize behavior *@
        <div id="red-ui-palette-separator" 
             class="red-ui-panel-separator"
             style="left: @(PaletteWidth)px;"
             @onmousedown="OnPaletteHandleMouseDown"
             @onmousedown:stopPropagation="true">
            <div class="red-ui-panel-separator-grip">
                <i class="fa fa-ellipsis-v"></i>
            </div>
        </div>

        @* Workspace area *@
        <div id="red-ui-workspace" style="left: @(PaletteWidth + 7)px; right: @(SidebarClosed ? 7 : SidebarWidth + 7)px;">
            <Workspaces @ref="workspacesRef" />
            @* View navigator mini-map - translated from view-navigator.js *@
            <ViewNavigator />
        </div>

        @* Editor stack for tray dialogs - positioned left of sidebar *@
        <div id="red-ui-editor-stack" tabindex="-1" style="right: @(SidebarClosed ? 8 : SidebarWidth + 8)px;">
            <EditorTray @ref="editorTrayRef" />
        </div>

        @* Sidebar separator/handle - translated from sidebarSeparator in sidebar.js *@
        <div id="red-ui-sidebar-separator" 
             class="red-ui-panel-separator @(SidebarClosed ? "collapsed" : "")"
             style="right: @(SidebarClosed ? 0 : SidebarWidth)px;"
             @onmousedown="OnSidebarHandleMouseDown"
             @onmousedown:stopPropagation="true">
            <div class="red-ui-panel-separator-grip">
                <i class="fa fa-ellipsis-v"></i>
            </div>
            <div class="red-ui-sidebar-control-right" @onclick="ToggleSidebar" @onclick:stopPropagation="true">
                <i class="fa @(SidebarClosed ? "fa-chevron-left" : "fa-chevron-right")"></i>
            </div>
        </div>

        @* Sidebar panel *@
        <div class="red-ui-sidebar-wrapper @(SidebarClosed ? "collapsed" : "")" style="position: absolute; top: 0; bottom: 0; right: 0; width: @(SidebarClosed ? 0 : SidebarWidth)px; z-index: 10; overflow: hidden;">
            <Sidebar @ref="sidebarRef" />
        </div>
    </div>

    @* Plugin and node configs *@
    <div id="red-ui-editor-plugin-configs"></div>
    <div id="red-ui-editor-node-configs"></div>

    @* Full shade overlay *@
    <div id="red-ui-full-shade" class="@(ShowFullShade ? "" : "hide")"></div>
</div>

@* Context menu component *@
<ContextMenu @ref="contextMenuRef" />

@* Notifications component *@
<Notifications @ref="notificationsRef" />

@* Search dialog - translated from ui/search.js (Ctrl+F) *@
<Search @ref="searchRef" />

@* Type search dialog - translated from ui/typeSearch.js (Ctrl+Space) *@
<TypeSearch @ref="typeSearchRef" OnNodeSelected="HandleQuickAddNode" />

@* Action list dialog - translated from ui/actionList.js (Ctrl+Shift+P) *@
<ActionList @ref="actionListRef" />

@* Tour/welcome wizard - translated from ui/tour *@
<Tour @ref="tourRef" />

@* User settings dialog - translated from ui/userSettings.js *@
<UserSettings @ref="userSettingsRef" />

@* Palette editor dialog - translated from ui/palette-editor.js *@
<PaletteEditor @ref="paletteEditorRef" />

@code {
    // ============================================================
    // MAPPING NOTES:
    // - var initialised = false → private bool _initialized
    // - options.apiRootUrl → ApiRootUrl parameter
    // - loader.start/end → IsLoading, LoadingProgress, LoadingMessage
    // - RED.comms.subscribe → Comms.Subscribe()
    // - $.ajax() → Http.GetFromJsonAsync()
    // ============================================================

    [Parameter]
    public string ApiRootUrl { get; set; } = "";

    private bool _initialized = false;
    private bool IsLoading = true;
    private int LoadingProgress = 0;
    private string LoadingMessage = "...";
    private bool SidebarClosed = true;
    private bool ShowHeaderShade = false;
    private bool ShowFullShade = false;
    private bool _preventKeyDefault = false;

    // ============================================================
    // Panel resize state - translated from sidebarSeparator and palette resize
    // ============================================================
    private int SidebarWidth = 315;
    private int PaletteWidth = 180;
    private bool _isResizingSidebar = false;
    private bool _isResizingPalette = false;
    private int _resizeStartX = 0;
    private int _resizeStartWidth = 0;
    private DotNetObjectReference<RedEditor>? _dotNetRef;

    // ============================================================
    // Multiplayer state - translated from multiplayer.js
    // ============================================================
    private bool _multiplayerEnabled = true;
    private List<Multiplayer.MultiplayerUser> _connectedUsers = new();

    // Component references
    private Workspaces? workspacesRef;
    private EditorTray? editorTrayRef;
    private Palette? paletteRef;
    private Sidebar? sidebarRef;
    private ContextMenu? contextMenuRef;
    private Notifications? notificationsRef;
    private Search? searchRef;
    private TypeSearch? typeSearchRef;
    private ActionList? actionListRef;
    private Tour? tourRef;
    private UserSettings? userSettingsRef;
    private PaletteEditor? paletteEditorRef;

    // Subscriptions for cleanup
    private List<IDisposable> _subscriptions = new();

    protected override async Task OnInitializedAsync()
    {
        // Translated from init() check
        if (_initialized)
        {
            // Already initialized - skip to avoid duplicate workspaces
            return;
        }
        _initialized = true;

        // Normalize API root URL (translated from options.apiRootUrl handling)
        if (!string.IsNullOrEmpty(ApiRootUrl) && !ApiRootUrl.EndsWith("/"))
        {
            ApiRootUrl += "/";
        }

        // For demo purposes, skip actual API calls and show UI immediately
        // In production, this would load from the API
        try
        {
            // Initialize with defaults (no API server needed for demo)
            State.Theme = new ThemeSettings();
            
            // Clear any existing workspaces and add a default one
            State.Workspaces.Clear();
            State.Workspaces.Add(new Workspace { Id = "flow1", Label = "Flow 1" });
            
            // Setup keyboard shortcuts
            SetupKeyboardHandlers();
            
            // Setup context menu handler
            SetupContextMenuHandler();
            
            // Complete loading immediately
            IsLoading = false;
            SidebarClosed = false;
            
            StateHasChanged();
        }
        catch (Exception ex)
        {
            await ShowNotificationAsync($"Failed to initialize editor: {ex.Message}", "error");
            IsLoading = false;
            StateHasChanged();
        }
    }

    /// <summary>
    /// Translated from $.getJSON(options.apiRootUrl+"theme", ...)
    /// </summary>
    private async Task LoadThemeAsync()
    {
        try
        {
            State.Theme = await Http.GetFromJsonAsync<ThemeSettings>($"{ApiRootUrl}theme");
        }
        catch
        {
            // Theme is optional, use defaults
            State.Theme = new ThemeSettings();
        }
    }

    /// <summary>
    /// Translated from loadEditor() function in red.js lines 838-889
    /// </summary>
    private async Task LoadEditorAsync()
    {
        // Initialize components - translated from RED.*.init() calls
        await State.Nodes.InitAsync();
        await State.Plugins.InitAsync();

        // Connect comms - translated from RED.comms.connect()
        await Comms.ConnectAsync();

        // Subscribe to notifications - translated from completeLoad() subscriptions
        SetupSubscriptions();

        // Load plugins - translated from loadPluginList()
        await LoadPluginListAsync();
    }

    /// <summary>
    /// Translated from loadPluginList() function
    /// </summary>
    private async Task LoadPluginListAsync()
    {
        ReportProgress(State.I18n.Translate("event.loadPlugins"), 10);

        try
        {
            var plugins = await Http.GetFromJsonAsync<List<PluginInfo>>($"{ApiRootUrl}plugins");
            State.Plugins.SetPluginList(plugins ?? new List<PluginInfo>());

            ReportProgress(State.I18n.Translate("event.loadPlugins"), 13);

            // Load plugin catalogs
            await State.I18n.LoadPluginCatalogsAsync();

            // Load plugins HTML
            await LoadPluginsAsync();

            // Then load node list
            await LoadNodeListAsync();
        }
        catch (Exception ex)
        {
            await ShowNotificationAsync($"Failed to load plugins: {ex.Message}", "error");
        }
    }

    /// <summary>
    /// Translated from loadPlugins() function
    /// </summary>
    private async Task LoadPluginsAsync()
    {
        ReportProgress(State.I18n.Translate("event.loadPlugins", new { count = "" }), 17);

        try
        {
            var lang = State.Settings.GetLocal("editor-language") ?? State.I18n.DetectLanguage();
            
            // Load plugin HTML content
            using var request = new HttpRequestMessage(HttpMethod.Get, $"{ApiRootUrl}plugins");
            request.Headers.Add("Accept", "text/html");
            request.Headers.Add("Accept-Language", lang);

            var response = await Http.SendAsync(request);
            var data = await response.Content.ReadAsStringAsync();

            // Parse and append plugin configs
            var configs = ParsePluginConfigs(data);
            foreach (var config in configs)
            {
                await AppendPluginConfigAsync(config);
            }
        }
        catch (Exception ex)
        {
            await ShowNotificationAsync($"Failed to load plugins HTML: {ex.Message}", "warning");
        }
    }

    /// <summary>
    /// Translated from loadNodeList() function
    /// </summary>
    private async Task LoadNodeListAsync()
    {
        ReportProgress(State.I18n.Translate("event.loadPalette"), 20);

        try
        {
            var nodes = await Http.GetFromJsonAsync<List<NodeSetInfo>>($"{ApiRootUrl}nodes");
            State.Nodes.SetNodeList(nodes ?? new List<NodeSetInfo>());

            ReportProgress(State.I18n.Translate("event.loadNodeCatalogs"), 25);

            await State.I18n.LoadNodeCatalogsAsync();

            // Load icons
            await LoadIconListAsync();

            // Load nodes HTML
            await LoadNodesAsync();
        }
        catch (Exception ex)
        {
            await ShowNotificationAsync($"Failed to load nodes: {ex.Message}", "error");
        }
    }

    /// <summary>
    /// Translated from loadIconList() function
    /// </summary>
    private async Task LoadIconListAsync()
    {
        try
        {
            var icons = await Http.GetFromJsonAsync<Dictionary<string, List<string>>>($"{ApiRootUrl}icons");
            State.Nodes.SetIconSets(icons ?? new Dictionary<string, List<string>>());
        }
        catch
        {
            // Icons are optional
        }
    }

    /// <summary>
    /// Translated from loadNodes() function
    /// </summary>
    private async Task LoadNodesAsync()
    {
        ReportProgress(State.I18n.Translate("event.loadNodes", new { count = "" }), 30);

        try
        {
            var lang = State.Settings.GetLocal("editor-language") ?? State.I18n.DetectLanguage();

            using var request = new HttpRequestMessage(HttpMethod.Get, $"{ApiRootUrl}nodes");
            request.Headers.Add("Accept", "text/html");
            request.Headers.Add("Accept-Language", lang);

            var response = await Http.SendAsync(request);
            var data = await response.Content.ReadAsStringAsync();

            var configs = ParseNodeConfigs(data);
            var totalCount = configs.Count;

            for (int i = 0; i < configs.Count; i++)
            {
                ReportProgress(
                    State.I18n.Translate("event.loadNodes", new { count = $"{i + 1}/{totalCount}" }),
                    30 + (int)(((double)(i + 1) / totalCount) * 40)
                );
                await AppendNodeConfigAsync(configs[i]);
            }

            // Load flows
            await LoadFlowsAsync();
        }
        catch (Exception ex)
        {
            await ShowNotificationAsync($"Failed to load nodes HTML: {ex.Message}", "error");
        }
    }

    /// <summary>
    /// Translated from loadFlows() function
    /// </summary>
    private async Task LoadFlowsAsync()
    {
        ReportProgress(State.I18n.Translate("event.loadFlows"), 80);

        try
        {
            var flowsData = await Http.GetFromJsonAsync<FlowsResponse>($"{ApiRootUrl}flows");

            if (flowsData != null)
            {
                State.Nodes.SetVersion(flowsData.Rev);

                ReportProgress(State.I18n.Translate("event.importFlows"), 90);

                State.Nodes.Import(flowsData.Flows);
                State.Nodes.SetDirty(false);

                // Trigger redraw
                workspacesRef?.Redraw(true);

                // Show first visible workspace
                if (State.Workspaces.Count > 0)
                {
                    State.Workspaces.Show(State.Workspaces.GetWorkspaceOrder()[0]);
                }

                State.Events.Emit("flows:loaded", null);
            }

            // Complete loading
            await CompleteLoadAsync();
        }
        catch (Exception ex)
        {
            await ShowNotificationAsync(
                State.I18n.Translate("event.importError", new { message = ex.Message }),
                "error"
            );
            await CompleteLoadAsync();
        }
    }

    /// <summary>
    /// Translated from completeLoad() function
    /// </summary>
    private async Task CompleteLoadAsync()
    {
        // Show UI
        IsLoading = false;
        SidebarClosed = false;

        // Show sidebar - translated from RED.sidebar.show(":first", true)
        sidebarRef?.Show("info", true);

        // End loader
        await Task.Delay(100); // Translated from setTimeout(..., 100)
        ReportProgress("", 0);

        StateHasChanged();
    }

    /// <summary>
    /// Setup comms subscriptions - translated from completeLoad() subscriptions
    /// </summary>
    private void SetupSubscriptions()
    {
        // Subscribe to notifications - translated from RED.comms.subscribe("notification/#", ...)
        _subscriptions.Add(Comms.Subscribe("notification/#", HandleNotification));

        // Subscribe to status updates - translated from RED.comms.subscribe("status/#", ...)
        _subscriptions.Add(Comms.Subscribe("status/#", HandleStatusUpdate));

        // Subscribe to event log - translated from RED.comms.subscribe("event-log/#", ...)
        _subscriptions.Add(Comms.Subscribe("event-log/#", HandleEventLog));

        // Subscribe to multiplayer/user presence - translated from multiplayer.js subscriptions
        _subscriptions.Add(Comms.Subscribe("multiplayer/#", HandleMultiplayerUpdate));
    }

    /// <summary>
    /// Handle multiplayer updates - user presence and cursor positions
    /// Translated from multiplayer.js
    /// </summary>
    private void HandleMultiplayerUpdate(string topic, object? payload)
    {
        var parts = topic.Split('/');
        if (parts.Length < 2) return;

        var action = parts[1];
        
        switch (action)
        {
            case "join":
                if (payload is Multiplayer.MultiplayerUser newUser)
                {
                    if (!_connectedUsers.Any(u => u.Id == newUser.Id))
                    {
                        _connectedUsers.Add(newUser);
                        InvokeAsync(StateHasChanged);
                    }
                }
                break;
                
            case "leave":
                if (payload is string userId)
                {
                    _connectedUsers.RemoveAll(u => u.Id == userId);
                    InvokeAsync(StateHasChanged);
                }
                break;
                
            case "cursor":
            case "selection":
                // Update existing user's cursor or selection
                // Implementation would update the user in _connectedUsers
                InvokeAsync(StateHasChanged);
                break;
        }
    }

    /// <summary>
    /// Handle notification messages - translated from notification subscription handler
    /// </summary>
    private void HandleNotification(string topic, object? payload)
    {
        var parts = topic.Split('/');
        if (parts.Length < 2) return;

        var notificationId = parts[1];

        // Skip handled elsewhere
        if (notificationId is "runtime-deploy" or "node" or "flows-run-state")
            return;

        if (payload is NotificationMessage msg && !string.IsNullOrEmpty(msg.Text))
        {
            InvokeAsync(async () =>
            {
                await ShowNotificationAsync(
                    State.I18n.Translate(msg.Text, msg),
                    msg.Type ?? "info",
                    msg.Timeout
                );
            });
        }
    }

    /// <summary>
    /// Handle status updates - translated from status/# subscription handler
    /// </summary>
    private void HandleStatusUpdate(string topic, object? payload)
    {
        var parts = topic.Split('/');
        if (parts.Length < 2) return;

        var nodeId = parts[1];
        var node = State.Nodes.GetNode(nodeId);

        if (node != null && payload is NodeStatus status)
        {
            node.Status = status;
            node.DirtyStatus = true;
            node.Dirty = true;

            InvokeAsync(() =>
            {
                workspacesRef?.RedrawStatus(node);
                StateHasChanged();
            });
        }
    }

    /// <summary>
    /// Handle event log messages
    /// </summary>
    private void HandleEventLog(string topic, object? payload)
    {
        var id = topic.Length > 9 ? topic.Substring(9) : "";
        State.EventLog.Log(id, payload);
    }

    // ============================================================
    // Helper methods
    // ============================================================

    private void ReportProgress(string text, int percent)
    {
        LoadingMessage = text;
        LoadingProgress = percent;
        InvokeAsync(StateHasChanged);
    }

    private List<string> ParsePluginConfigs(string data)
    {
        // Translated from: data.trim().split(/(?=<!-- --- \[red-plugin:\S+\] --- -->)/)
        if (string.IsNullOrWhiteSpace(data)) return new List<string>();

        var configs = new List<string>();
        var pattern = @"(?=<!-- --- \[red-plugin:\S+\] --- -->)";
        var parts = System.Text.RegularExpressions.Regex.Split(data.Trim(), pattern);

        foreach (var part in parts)
        {
            if (!string.IsNullOrWhiteSpace(part))
            {
                configs.Add(part);
            }
        }

        return configs;
    }

    private List<string> ParseNodeConfigs(string data)
    {
        // Translated from: data.trim().split(/(?=<!-- --- \[red-module:\S+\] --- -->)/)
        if (string.IsNullOrWhiteSpace(data)) return new List<string>();

        var configs = new List<string>();
        var pattern = @"(?=<!-- --- \[red-module:\S+\] --- -->)";
        var parts = System.Text.RegularExpressions.Regex.Split(data.Trim(), pattern);

        foreach (var part in parts)
        {
            if (!string.IsNullOrWhiteSpace(part))
            {
                configs.Add(part);
            }
        }

        return configs;
    }

    private Task AppendPluginConfigAsync(string config)
    {
        // Store plugin config for later use by node editor
        State.PluginConfigs.Add(config);
        return Task.CompletedTask;
    }

    private Task AppendNodeConfigAsync(string config)
    {
        // Store node config for later use by node editor
        State.NodeConfigs.Add(config);
        return Task.CompletedTask;
    }

    private async Task ShowNotificationAsync(string message, string type, int? timeout = null)
    {
        if (notificationsRef != null)
        {
            await notificationsRef.ShowAsync(message, type, timeout);
        }
    }

    private bool _menuOpen = false;
    
    private void ToggleMenu()
    {
        _menuOpen = !_menuOpen;
        State.Menu.Toggle();
        StateHasChanged();
    }

    private void CloseMenu()
    {
        _menuOpen = false;
        StateHasChanged();
    }

    private async Task HandleDeploy()
    {
        // Delegate to deploy service
        await State.Deploy.DeployAsync();
    }

    // ============================================================
    // Sidebar toggle - translated from RED.menu.toggleSelected("menu-item-sidebar")
    // ============================================================
    private void ToggleSidebar()
    {
        SidebarClosed = !SidebarClosed;
        State.Events.Emit("sidebar:resize", null);
        StateHasChanged();
    }

    // ============================================================
    // Panel resize handlers - translated from setupSidebarSeparator()
    // ============================================================
    
    /// <summary>
    /// Handle mousedown on sidebar resize handle
    /// Translated from: $(d).draggable({ start: ... })
    /// </summary>
    private async Task OnSidebarHandleMouseDown(MouseEventArgs e)
    {
        _isResizingSidebar = true;
        _resizeStartX = (int)e.ClientX;
        _resizeStartWidth = SidebarWidth;
        
        // Register global mouse events via JS
        _dotNetRef = DotNetObjectReference.Create(this);
        await JS.InvokeVoidAsync("startPanelResize", _dotNetRef, "sidebar");
    }

    /// <summary>
    /// Handle mousedown on palette resize handle
    /// </summary>
    private async Task OnPaletteHandleMouseDown(MouseEventArgs e)
    {
        _isResizingPalette = true;
        _resizeStartX = (int)e.ClientX;
        _resizeStartWidth = PaletteWidth;
        
        // Register global mouse events via JS
        _dotNetRef = DotNetObjectReference.Create(this);
        await JS.InvokeVoidAsync("startPanelResize", _dotNetRef, "palette");
    }

    /// <summary>
    /// Called from JavaScript when mouse moves during resize
    /// </summary>
    [JSInvokable]
    public void OnPanelResizeMove(string panel, int clientX)
    {
        var delta = clientX - _resizeStartX;
        
        if (panel == "sidebar")
        {
            // Sidebar moves from right, so delta is inverted
            var newWidth = Math.Max(150, Math.Min(600, _resizeStartWidth - delta));
            SidebarWidth = newWidth;
            
            // If resizing from collapsed state
            if (SidebarClosed && newWidth > 150)
            {
                SidebarClosed = false;
            }
        }
        else if (panel == "palette")
        {
            // Palette moves from left
            var newWidth = Math.Max(100, Math.Min(400, _resizeStartWidth + delta));
            PaletteWidth = newWidth;
        }
        
        InvokeAsync(StateHasChanged);
    }

    /// <summary>
    /// Called from JavaScript when mouse is released after resize
    /// </summary>
    [JSInvokable]
    public void OnPanelResizeEnd(string panel)
    {
        if (panel == "sidebar")
        {
            _isResizingSidebar = false;
            
            // Close sidebar if dragged too small - translated from sidebarSeparator.closing
            if (SidebarWidth < 150)
            {
                SidebarClosed = true;
                SidebarWidth = 315; // Reset to default
            }
            
            State.Events.Emit("sidebar:resize", null);
        }
        else if (panel == "palette")
        {
            _isResizingPalette = false;
        }
        
        _dotNetRef?.Dispose();
        _dotNetRef = null;
        
        InvokeAsync(StateHasChanged);
    }

    // ============================================================
    // Keyboard handling - translated from ui/keyboard.js
    // ============================================================
    
    /// <summary>
    /// Handle keyboard events at the editor level
    /// Translated from keyboard.js handleKeyEvent
    /// </summary>
    private void HandleKeyDown(KeyboardEventArgs e)
    {
        var key = e.Key.ToLowerInvariant();
        var handled = KeyboardService.HandleKeyEvent(key, e.CtrlKey, e.ShiftKey, e.AltKey);
        
        if (handled)
        {
            _preventKeyDefault = true;
        }
        else
        {
            // Handle specific shortcuts directly
            if (e.CtrlKey && key == "f")
            {
                // Open search dialog
                searchRef?.Show();
                _preventKeyDefault = true;
            }
            else if (e.CtrlKey && key == " ")
            {
                // Open type search (quick add node)
                typeSearchRef?.Show();
                _preventKeyDefault = true;
            }
            else if (e.CtrlKey && e.ShiftKey && key == "p")
            {
                // Open action list
                actionListRef?.Show();
                _preventKeyDefault = true;
            }
            else if (e.CtrlKey && key == "z" && !e.ShiftKey)
            {
                // Undo
                HistoryService.Undo();
                _preventKeyDefault = true;
            }
            else if ((e.CtrlKey && e.ShiftKey && key == "z") || (e.CtrlKey && key == "y"))
            {
                // Redo
                HistoryService.Redo();
                _preventKeyDefault = true;
            }
            else if (e.CtrlKey && key == "c")
            {
                // Copy
                ClipboardService.CopySelection(State.Nodes.GetSelectedNodes());
                _preventKeyDefault = true;
            }
            else if (e.CtrlKey && key == "v")
            {
                // Paste
                var pastedNodes = ClipboardService.PasteNodes();
                foreach (var node in pastedNodes)
                {
                    State.Nodes.Add(node);
                }
                workspacesRef?.Redraw(true);
                _preventKeyDefault = true;
            }
            else if (e.CtrlKey && key == "x")
            {
                // Cut
                ClipboardService.CopySelection(State.Nodes.GetSelectedNodes());
                State.Nodes.DeleteSelection();
                workspacesRef?.Redraw(true);
                _preventKeyDefault = true;
            }
            else if (key == "delete" || key == "backspace")
            {
                // Delete selection
                State.Nodes.DeleteSelection();
                workspacesRef?.Redraw(true);
                _preventKeyDefault = true;
            }
            else
            {
                _preventKeyDefault = false;
            }
        }
        
        StateHasChanged();
    }

    /// <summary>
    /// Handle quick add node from type search
    /// </summary>
    private void HandleQuickAddNode(string nodeType)
    {
        // Create a new node of the specified type at a default position
        var newNode = new FlowNode
        {
            Id = Guid.NewGuid().ToString(),
            Type = nodeType,
            X = 100,
            Y = 100,
            Z = State.Workspaces.Active(),
            Dirty = true
        };
        
        State.Nodes.Add(newNode);
        State.Nodes.SetDirty(true);
        workspacesRef?.Redraw(true);
    }

    /// <summary>
    /// Setup keyboard action handlers
    /// Called during initialization to wire up keyboard shortcuts to actions
    /// </summary>
    private void SetupKeyboardHandlers()
    {
        KeyboardService.AddHandler("core:copy-selection-to-internal-clipboard", () =>
        {
            ClipboardService.CopySelection(State.Nodes.GetSelectedNodes());
        });
        
        KeyboardService.AddHandler("core:paste-from-internal-clipboard", () =>
        {
            var pastedNodes = ClipboardService.PasteNodes();
            foreach (var node in pastedNodes)
            {
                State.Nodes.Add(node);
            }
            workspacesRef?.Redraw(true);
        });
        
        KeyboardService.AddHandler("core:undo", () => HistoryService.Undo());
        KeyboardService.AddHandler("core:redo", () => HistoryService.Redo());
        
        KeyboardService.AddHandler("core:delete-selection", () =>
        {
            State.Nodes.DeleteSelection();
            workspacesRef?.Redraw(true);
        });
        
        KeyboardService.AddHandler("core:search", () => searchRef?.Show());
        KeyboardService.AddHandler("core:show-action-list", () => actionListRef?.Show());
        
        KeyboardService.AddHandler("core:toggle-sidebar", () =>
        {
            SidebarClosed = !SidebarClosed;
            StateHasChanged();
        });
        
        KeyboardService.AddHandler("core:deploy", async () => await HandleDeploy());
    }

    /// <summary>
    /// Setup context menu event handler
    /// Called during initialization to wire up context menu
    /// </summary>
    private void SetupContextMenuHandler()
    {
        State.Events.On("view:contextmenu", obj =>
        {
            if (obj is { } data && contextMenuRef != null)
            {
                // Build context menu items
                var selectedNodes = State.Nodes.GetSelectedNodes();
                var hasSelection = selectedNodes.Any();
                
                var items = new List<ContextMenu.ContextMenuItem>
                {
                    new() { Label = "Add node...", Icon = "fa-plus", OnClick = () => typeSearchRef?.Show() },
                    new() { IsSeparator = true },
                    new() { Label = "Cut", Icon = "fa-cut", Shortcut = "Ctrl+X", Disabled = !hasSelection, OnClick = () => {
                        ClipboardService.CopySelection(State.Nodes.GetSelectedNodes());
                        State.Nodes.DeleteSelection();
                        workspacesRef?.Redraw(true);
                    }},
                    new() { Label = "Copy", Icon = "fa-copy", Shortcut = "Ctrl+C", Disabled = !hasSelection, OnClick = () => {
                        ClipboardService.CopySelection(State.Nodes.GetSelectedNodes());
                    }},
                    new() { Label = "Paste", Icon = "fa-paste", Shortcut = "Ctrl+V", Disabled = !ClipboardService.HasContent, OnClick = () => {
                        var pastedNodes = ClipboardService.PasteNodes();
                        foreach (var node in pastedNodes)
                        {
                            State.Nodes.Add(node);
                        }
                        workspacesRef?.Redraw(true);
                    }},
                    new() { IsSeparator = true },
                    new() { Label = "Group selection", Icon = "fa-object-group", Shortcut = "Ctrl+Shift+G", Disabled = selectedNodes.Count() < 2, OnClick = () => {
                        State.GroupManager.CreateGroup(State.Nodes.GetSelectedNodes().ToList(), State.Workspaces.Active());
                        workspacesRef?.Redraw(true);
                    }},
                    new() { Label = "Ungroup selection", Icon = "fa-object-ungroup", Disabled = !hasSelection, OnClick = () => {
                        State.GroupManager.UngroupSelection(State.Nodes.GetSelectedNodes().ToList());
                        workspacesRef?.Redraw(true);
                    }},
                    new() { IsSeparator = true },
                    new() { Label = "Create subflow", Icon = "fa-cube", Shortcut = "Ctrl+Shift+S", Disabled = !hasSelection, OnClick = () => {
                        State.SubflowManager.CreateSubflow(State.Nodes.GetSelectedNodes().ToList());
                        workspacesRef?.Redraw(true);
                    }},
                    new() { Label = "Convert to subflow", Icon = "fa-cubes", Disabled = selectedNodes.Count() != 1, OnClick = () => {
                        var node = selectedNodes.FirstOrDefault();
                        if (node != null)
                        {
                            State.SubflowManager.ConvertToSubflow(node);
                            workspacesRef?.Redraw(true);
                        }
                    }},
                    new() { IsSeparator = true },
                    new() { Label = "Delete", Icon = "fa-trash", Shortcut = "Delete", Disabled = !hasSelection, OnClick = () => {
                        State.Nodes.DeleteSelection();
                        workspacesRef?.Redraw(true);
                    }},
                    new() { IsSeparator = true },
                    new() { Label = "Select all", Icon = "fa-check-square-o", Shortcut = "Ctrl+A", OnClick = () => {
                        State.Nodes.SelectAll(State.Workspaces.Active());
                        workspacesRef?.Redraw(true);
                    }}
                };

                // Get position from dynamic object
                double x = 100, y = 100;
                var type = data.GetType();
                var xProp = type.GetProperty("X");
                var yProp = type.GetProperty("Y");
                if (xProp != null) x = Convert.ToDouble(xProp.GetValue(data));
                if (yProp != null) y = Convert.ToDouble(yProp.GetValue(data));

                contextMenuRef.Show(x, y, items);
                InvokeAsync(StateHasChanged);
            }
        });
    }

    public async ValueTask DisposeAsync()
    {
        // Cleanup subscriptions
        foreach (var sub in _subscriptions)
        {
            sub.Dispose();
        }
        _subscriptions.Clear();

        // Cleanup DotNetObjectReference
        _dotNetRef?.Dispose();
        _dotNetRef = null;

        // Disconnect comms
        await Comms.DisconnectAsync();
    }
}
