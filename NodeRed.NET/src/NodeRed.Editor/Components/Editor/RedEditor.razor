@* ============================================================
   SOURCE: packages/node_modules/@node-red/editor-client/src/js/red.js
   SOURCE: packages/node_modules/@node-red/editor-client/src/js/main.js
   ============================================================
   ORIGINAL CODE (red.js lines 931-956):
   ------------------------------------------------------------
   function init(options) {
       if (initialised) {
           throw new Error("RED already initialised");
       }
       initialised = true;
       if(window.ace) { window.ace.require("ace/ext/language_tools"); }
       options = options || {};
       options.apiRootUrl = options.apiRootUrl || "";
       if (options.apiRootUrl && !/\/$/.test(options.apiRootUrl)) {
           options.apiRootUrl = options.apiRootUrl+"/";
       }
       options.target = $("#red-ui-editor");
       options.target.addClass("red-ui-editor");

       buildEditor(options);

       RED.i18n.init(options, function() {
           RED.settings.init(options, function() {
               if (knownThemes) {
                   RED.settings.editorTheme = RED.settings.editorTheme || {};
                   RED.settings.editorTheme.themes = knownThemes;
               }
               loadEditor();
           });
       })
   }
   ------------------------------------------------------------
   TRANSLATION:
   This Blazor component translates the RED.init() and buildEditor() functions.
   - jQuery DOM manipulation → Blazor component rendering
   - $.getJSON() → HttpClient with async/await
   - Event subscriptions → Component lifecycle events
   ============================================================ *@

@using Microsoft.AspNetCore.Components
@using Microsoft.JSInterop
@using NodeRed.Editor.Services
@inject EditorState State
@inject IEditorComms Comms
@inject HttpClient Http
@inject IJSRuntime JS
@implements IAsyncDisposable

<div id="red-ui-editor" class="red-ui-editor">
    @* Header *@
    <div id="red-ui-header">
        <span class="red-ui-header-logo">
            @if (!string.IsNullOrEmpty(State.Theme?.Header?.Image))
            {
                <a href="@(State.Theme?.Header?.Url ?? "#")">
                    <img src="@State.Theme.Header.Image" alt="Logo" />
                    @if (!string.IsNullOrEmpty(State.Theme?.Header?.Title))
                    {
                        <span>@State.Theme.Header.Title</span>
                    }
                </a>
            }
            else
            {
                <span>Node-RED.NET</span>
            }
        </span>
        <ul class="red-ui-header-toolbar @(IsLoading ? "hide" : "")">
            @* Deploy button - translated from ui/deploy.js *@
            <li>
                <DeployButton OnDeploy="HandleDeploy" />
            </li>
            @* Menu button - translated from main.js buildMainMenu() *@
            <li>
                <a id="red-ui-header-button-sidemenu" class="button" @onclick="ToggleMenu">
                    <i class="fa fa-bars"></i>
                </a>
            </li>
        </ul>
        <div id="red-ui-header-shade" class="@(ShowHeaderShade ? "" : "hide")"></div>
    </div>

    @* Main container - translated from buildEditor() *@
    <div id="red-ui-main-container" class="@(SidebarClosed ? "red-ui-sidebar-closed" : "") @(IsLoading ? "hide" : "")">
        @* Loading progress - translated from loader object *@
        @if (IsLoading)
        {
            <Loader Progress="@LoadingProgress" Message="@LoadingMessage" />
        }

        @* Palette panel *@
        <div class="red-ui-palette-wrapper" style="position: absolute; top: 0; bottom: 0; left: 0; width: @(PaletteWidth)px; z-index: 10;">
            <Palette @ref="paletteRef" />
        </div>

        @* Palette separator/handle - translated from palette resize behavior *@
        <div id="red-ui-palette-separator" 
             class="red-ui-panel-separator"
             style="left: @(PaletteWidth)px;"
             @onmousedown="OnPaletteHandleMouseDown"
             @onmousedown:stopPropagation="true">
            <div class="red-ui-panel-separator-grip">
                <i class="fa fa-ellipsis-v"></i>
            </div>
        </div>

        @* Workspace area *@
        <div id="red-ui-workspace" style="left: @(PaletteWidth + 7)px; right: @(SidebarClosed ? 7 : SidebarWidth + 7)px;">
            <Workspaces @ref="workspacesRef" />
        </div>

        @* Editor stack for tray dialogs - positioned left of sidebar *@
        <div id="red-ui-editor-stack" tabindex="-1" style="right: @(SidebarClosed ? 8 : SidebarWidth + 8)px;">
            <EditorTray @ref="editorTrayRef" />
        </div>

        @* Sidebar separator/handle - translated from sidebarSeparator in sidebar.js *@
        <div id="red-ui-sidebar-separator" 
             class="red-ui-panel-separator @(SidebarClosed ? "collapsed" : "")"
             style="right: @(SidebarClosed ? 0 : SidebarWidth)px;"
             @onmousedown="OnSidebarHandleMouseDown"
             @onmousedown:stopPropagation="true">
            <div class="red-ui-panel-separator-grip">
                <i class="fa fa-ellipsis-v"></i>
            </div>
            <div class="red-ui-sidebar-control-right" @onclick="ToggleSidebar" @onclick:stopPropagation="true">
                <i class="fa @(SidebarClosed ? "fa-chevron-left" : "fa-chevron-right")"></i>
            </div>
        </div>

        @* Sidebar panel *@
        <div class="red-ui-sidebar-wrapper @(SidebarClosed ? "collapsed" : "")" style="position: absolute; top: 0; bottom: 0; right: 0; width: @(SidebarClosed ? 0 : SidebarWidth)px; z-index: 10; overflow: hidden;">
            <Sidebar @ref="sidebarRef" />
        </div>
    </div>

    @* Plugin and node configs *@
    <div id="red-ui-editor-plugin-configs"></div>
    <div id="red-ui-editor-node-configs"></div>

    @* Full shade overlay *@
    <div id="red-ui-full-shade" class="@(ShowFullShade ? "" : "hide")"></div>
</div>

@* Context menu component *@
<ContextMenu @ref="contextMenuRef" />

@* Notifications component *@
<Notifications @ref="notificationsRef" />

@code {
    // ============================================================
    // MAPPING NOTES:
    // - var initialised = false → private bool _initialized
    // - options.apiRootUrl → ApiRootUrl parameter
    // - loader.start/end → IsLoading, LoadingProgress, LoadingMessage
    // - RED.comms.subscribe → Comms.Subscribe()
    // - $.ajax() → Http.GetFromJsonAsync()
    // ============================================================

    [Parameter]
    public string ApiRootUrl { get; set; } = "";

    private bool _initialized = false;
    private bool IsLoading = true;
    private int LoadingProgress = 0;
    private string LoadingMessage = "...";
    private bool SidebarClosed = true;
    private bool ShowHeaderShade = false;
    private bool ShowFullShade = false;

    // ============================================================
    // Panel resize state - translated from sidebarSeparator and palette resize
    // ============================================================
    private int SidebarWidth = 315;
    private int PaletteWidth = 180;
    private bool _isResizingSidebar = false;
    private bool _isResizingPalette = false;
    private int _resizeStartX = 0;
    private int _resizeStartWidth = 0;
    private DotNetObjectReference<RedEditor>? _dotNetRef;

    // Component references
    private Workspaces? workspacesRef;
    private EditorTray? editorTrayRef;
    private Palette? paletteRef;
    private Sidebar? sidebarRef;
    private ContextMenu? contextMenuRef;
    private Notifications? notificationsRef;

    // Subscriptions for cleanup
    private List<IDisposable> _subscriptions = new();

    protected override async Task OnInitializedAsync()
    {
        // Translated from init() check
        if (_initialized)
        {
            throw new InvalidOperationException("RED already initialised");
        }
        _initialized = true;

        // Normalize API root URL (translated from options.apiRootUrl handling)
        if (!string.IsNullOrEmpty(ApiRootUrl) && !ApiRootUrl.EndsWith("/"))
        {
            ApiRootUrl += "/";
        }

        // For demo purposes, skip actual API calls and show UI immediately
        // In production, this would load from the API
        try
        {
            // Initialize with defaults (no API server needed for demo)
            State.Theme = new ThemeSettings();
            
            // Add a default workspace
            State.Workspaces.Add(new Workspace { Id = "flow1", Label = "Flow 1" });
            
            // Complete loading immediately
            IsLoading = false;
            SidebarClosed = false;
            
            StateHasChanged();
        }
        catch (Exception ex)
        {
            await ShowNotificationAsync($"Failed to initialize editor: {ex.Message}", "error");
            IsLoading = false;
            StateHasChanged();
        }
    }

    /// <summary>
    /// Translated from $.getJSON(options.apiRootUrl+"theme", ...)
    /// </summary>
    private async Task LoadThemeAsync()
    {
        try
        {
            State.Theme = await Http.GetFromJsonAsync<ThemeSettings>($"{ApiRootUrl}theme");
        }
        catch
        {
            // Theme is optional, use defaults
            State.Theme = new ThemeSettings();
        }
    }

    /// <summary>
    /// Translated from loadEditor() function in red.js lines 838-889
    /// </summary>
    private async Task LoadEditorAsync()
    {
        // Initialize components - translated from RED.*.init() calls
        await State.Nodes.InitAsync();
        await State.Plugins.InitAsync();

        // Connect comms - translated from RED.comms.connect()
        await Comms.ConnectAsync();

        // Subscribe to notifications - translated from completeLoad() subscriptions
        SetupSubscriptions();

        // Load plugins - translated from loadPluginList()
        await LoadPluginListAsync();
    }

    /// <summary>
    /// Translated from loadPluginList() function
    /// </summary>
    private async Task LoadPluginListAsync()
    {
        ReportProgress(State.I18n.Translate("event.loadPlugins"), 10);

        try
        {
            var plugins = await Http.GetFromJsonAsync<List<PluginInfo>>($"{ApiRootUrl}plugins");
            State.Plugins.SetPluginList(plugins ?? new List<PluginInfo>());

            ReportProgress(State.I18n.Translate("event.loadPlugins"), 13);

            // Load plugin catalogs
            await State.I18n.LoadPluginCatalogsAsync();

            // Load plugins HTML
            await LoadPluginsAsync();

            // Then load node list
            await LoadNodeListAsync();
        }
        catch (Exception ex)
        {
            await ShowNotificationAsync($"Failed to load plugins: {ex.Message}", "error");
        }
    }

    /// <summary>
    /// Translated from loadPlugins() function
    /// </summary>
    private async Task LoadPluginsAsync()
    {
        ReportProgress(State.I18n.Translate("event.loadPlugins", new { count = "" }), 17);

        try
        {
            var lang = State.Settings.GetLocal("editor-language") ?? State.I18n.DetectLanguage();
            
            // Load plugin HTML content
            using var request = new HttpRequestMessage(HttpMethod.Get, $"{ApiRootUrl}plugins");
            request.Headers.Add("Accept", "text/html");
            request.Headers.Add("Accept-Language", lang);

            var response = await Http.SendAsync(request);
            var data = await response.Content.ReadAsStringAsync();

            // Parse and append plugin configs
            var configs = ParsePluginConfigs(data);
            foreach (var config in configs)
            {
                await AppendPluginConfigAsync(config);
            }
        }
        catch (Exception ex)
        {
            await ShowNotificationAsync($"Failed to load plugins HTML: {ex.Message}", "warning");
        }
    }

    /// <summary>
    /// Translated from loadNodeList() function
    /// </summary>
    private async Task LoadNodeListAsync()
    {
        ReportProgress(State.I18n.Translate("event.loadPalette"), 20);

        try
        {
            var nodes = await Http.GetFromJsonAsync<List<NodeSetInfo>>($"{ApiRootUrl}nodes");
            State.Nodes.SetNodeList(nodes ?? new List<NodeSetInfo>());

            ReportProgress(State.I18n.Translate("event.loadNodeCatalogs"), 25);

            await State.I18n.LoadNodeCatalogsAsync();

            // Load icons
            await LoadIconListAsync();

            // Load nodes HTML
            await LoadNodesAsync();
        }
        catch (Exception ex)
        {
            await ShowNotificationAsync($"Failed to load nodes: {ex.Message}", "error");
        }
    }

    /// <summary>
    /// Translated from loadIconList() function
    /// </summary>
    private async Task LoadIconListAsync()
    {
        try
        {
            var icons = await Http.GetFromJsonAsync<Dictionary<string, List<string>>>($"{ApiRootUrl}icons");
            State.Nodes.SetIconSets(icons ?? new Dictionary<string, List<string>>());
        }
        catch
        {
            // Icons are optional
        }
    }

    /// <summary>
    /// Translated from loadNodes() function
    /// </summary>
    private async Task LoadNodesAsync()
    {
        ReportProgress(State.I18n.Translate("event.loadNodes", new { count = "" }), 30);

        try
        {
            var lang = State.Settings.GetLocal("editor-language") ?? State.I18n.DetectLanguage();

            using var request = new HttpRequestMessage(HttpMethod.Get, $"{ApiRootUrl}nodes");
            request.Headers.Add("Accept", "text/html");
            request.Headers.Add("Accept-Language", lang);

            var response = await Http.SendAsync(request);
            var data = await response.Content.ReadAsStringAsync();

            var configs = ParseNodeConfigs(data);
            var totalCount = configs.Count;

            for (int i = 0; i < configs.Count; i++)
            {
                ReportProgress(
                    State.I18n.Translate("event.loadNodes", new { count = $"{i + 1}/{totalCount}" }),
                    30 + (int)(((double)(i + 1) / totalCount) * 40)
                );
                await AppendNodeConfigAsync(configs[i]);
            }

            // Load flows
            await LoadFlowsAsync();
        }
        catch (Exception ex)
        {
            await ShowNotificationAsync($"Failed to load nodes HTML: {ex.Message}", "error");
        }
    }

    /// <summary>
    /// Translated from loadFlows() function
    /// </summary>
    private async Task LoadFlowsAsync()
    {
        ReportProgress(State.I18n.Translate("event.loadFlows"), 80);

        try
        {
            var flowsData = await Http.GetFromJsonAsync<FlowsResponse>($"{ApiRootUrl}flows");

            if (flowsData != null)
            {
                State.Nodes.SetVersion(flowsData.Rev);

                ReportProgress(State.I18n.Translate("event.importFlows"), 90);

                State.Nodes.Import(flowsData.Flows);
                State.Nodes.SetDirty(false);

                // Trigger redraw
                workspacesRef?.Redraw(true);

                // Show first visible workspace
                if (State.Workspaces.Count > 0)
                {
                    State.Workspaces.Show(State.Workspaces.GetWorkspaceOrder()[0]);
                }

                State.Events.Emit("flows:loaded", null);
            }

            // Complete loading
            await CompleteLoadAsync();
        }
        catch (Exception ex)
        {
            await ShowNotificationAsync(
                State.I18n.Translate("event.importError", new { message = ex.Message }),
                "error"
            );
            await CompleteLoadAsync();
        }
    }

    /// <summary>
    /// Translated from completeLoad() function
    /// </summary>
    private async Task CompleteLoadAsync()
    {
        // Show UI
        IsLoading = false;
        SidebarClosed = false;

        // Show sidebar - translated from RED.sidebar.show(":first", true)
        sidebarRef?.Show("info", true);

        // End loader
        await Task.Delay(100); // Translated from setTimeout(..., 100)
        ReportProgress("", 0);

        StateHasChanged();
    }

    /// <summary>
    /// Setup comms subscriptions - translated from completeLoad() subscriptions
    /// </summary>
    private void SetupSubscriptions()
    {
        // Subscribe to notifications - translated from RED.comms.subscribe("notification/#", ...)
        _subscriptions.Add(Comms.Subscribe("notification/#", HandleNotification));

        // Subscribe to status updates - translated from RED.comms.subscribe("status/#", ...)
        _subscriptions.Add(Comms.Subscribe("status/#", HandleStatusUpdate));

        // Subscribe to event log - translated from RED.comms.subscribe("event-log/#", ...)
        _subscriptions.Add(Comms.Subscribe("event-log/#", HandleEventLog));
    }

    /// <summary>
    /// Handle notification messages - translated from notification subscription handler
    /// </summary>
    private void HandleNotification(string topic, object? payload)
    {
        var parts = topic.Split('/');
        if (parts.Length < 2) return;

        var notificationId = parts[1];

        // Skip handled elsewhere
        if (notificationId is "runtime-deploy" or "node" or "flows-run-state")
            return;

        if (payload is NotificationMessage msg && !string.IsNullOrEmpty(msg.Text))
        {
            InvokeAsync(async () =>
            {
                await ShowNotificationAsync(
                    State.I18n.Translate(msg.Text, msg),
                    msg.Type ?? "info",
                    msg.Timeout
                );
            });
        }
    }

    /// <summary>
    /// Handle status updates - translated from status/# subscription handler
    /// </summary>
    private void HandleStatusUpdate(string topic, object? payload)
    {
        var parts = topic.Split('/');
        if (parts.Length < 2) return;

        var nodeId = parts[1];
        var node = State.Nodes.GetNode(nodeId);

        if (node != null && payload is NodeStatus status)
        {
            node.Status = status;
            node.DirtyStatus = true;
            node.Dirty = true;

            InvokeAsync(() =>
            {
                workspacesRef?.RedrawStatus(node);
                StateHasChanged();
            });
        }
    }

    /// <summary>
    /// Handle event log messages
    /// </summary>
    private void HandleEventLog(string topic, object? payload)
    {
        var id = topic.Length > 9 ? topic.Substring(9) : "";
        State.EventLog.Log(id, payload);
    }

    // ============================================================
    // Helper methods
    // ============================================================

    private void ReportProgress(string text, int percent)
    {
        LoadingMessage = text;
        LoadingProgress = percent;
        InvokeAsync(StateHasChanged);
    }

    private List<string> ParsePluginConfigs(string data)
    {
        // Translated from: data.trim().split(/(?=<!-- --- \[red-plugin:\S+\] --- -->)/)
        if (string.IsNullOrWhiteSpace(data)) return new List<string>();

        var configs = new List<string>();
        var pattern = @"(?=<!-- --- \[red-plugin:\S+\] --- -->)";
        var parts = System.Text.RegularExpressions.Regex.Split(data.Trim(), pattern);

        foreach (var part in parts)
        {
            if (!string.IsNullOrWhiteSpace(part))
            {
                configs.Add(part);
            }
        }

        return configs;
    }

    private List<string> ParseNodeConfigs(string data)
    {
        // Translated from: data.trim().split(/(?=<!-- --- \[red-module:\S+\] --- -->)/)
        if (string.IsNullOrWhiteSpace(data)) return new List<string>();

        var configs = new List<string>();
        var pattern = @"(?=<!-- --- \[red-module:\S+\] --- -->)";
        var parts = System.Text.RegularExpressions.Regex.Split(data.Trim(), pattern);

        foreach (var part in parts)
        {
            if (!string.IsNullOrWhiteSpace(part))
            {
                configs.Add(part);
            }
        }

        return configs;
    }

    private Task AppendPluginConfigAsync(string config)
    {
        // Store plugin config for later use by node editor
        State.PluginConfigs.Add(config);
        return Task.CompletedTask;
    }

    private Task AppendNodeConfigAsync(string config)
    {
        // Store node config for later use by node editor
        State.NodeConfigs.Add(config);
        return Task.CompletedTask;
    }

    private async Task ShowNotificationAsync(string message, string type, int? timeout = null)
    {
        if (notificationsRef != null)
        {
            await notificationsRef.ShowAsync(message, type, timeout);
        }
    }

    private void ToggleMenu()
    {
        State.Menu.Toggle();
        StateHasChanged();
    }

    private async Task HandleDeploy()
    {
        // Delegate to deploy service
        await State.Deploy.DeployAsync();
    }

    // ============================================================
    // Sidebar toggle - translated from RED.menu.toggleSelected("menu-item-sidebar")
    // ============================================================
    private void ToggleSidebar()
    {
        SidebarClosed = !SidebarClosed;
        State.Events.Emit("sidebar:resize", null);
        StateHasChanged();
    }

    // ============================================================
    // Panel resize handlers - translated from setupSidebarSeparator()
    // ============================================================
    
    /// <summary>
    /// Handle mousedown on sidebar resize handle
    /// Translated from: $(d).draggable({ start: ... })
    /// </summary>
    private async Task OnSidebarHandleMouseDown(MouseEventArgs e)
    {
        _isResizingSidebar = true;
        _resizeStartX = (int)e.ClientX;
        _resizeStartWidth = SidebarWidth;
        
        // Register global mouse events via JS
        _dotNetRef = DotNetObjectReference.Create(this);
        await JS.InvokeVoidAsync("startPanelResize", _dotNetRef, "sidebar");
    }

    /// <summary>
    /// Handle mousedown on palette resize handle
    /// </summary>
    private async Task OnPaletteHandleMouseDown(MouseEventArgs e)
    {
        _isResizingPalette = true;
        _resizeStartX = (int)e.ClientX;
        _resizeStartWidth = PaletteWidth;
        
        // Register global mouse events via JS
        _dotNetRef = DotNetObjectReference.Create(this);
        await JS.InvokeVoidAsync("startPanelResize", _dotNetRef, "palette");
    }

    /// <summary>
    /// Called from JavaScript when mouse moves during resize
    /// </summary>
    [JSInvokable]
    public void OnPanelResizeMove(string panel, int clientX)
    {
        var delta = clientX - _resizeStartX;
        
        if (panel == "sidebar")
        {
            // Sidebar moves from right, so delta is inverted
            var newWidth = Math.Max(150, Math.Min(600, _resizeStartWidth - delta));
            SidebarWidth = newWidth;
            
            // If resizing from collapsed state
            if (SidebarClosed && newWidth > 150)
            {
                SidebarClosed = false;
            }
        }
        else if (panel == "palette")
        {
            // Palette moves from left
            var newWidth = Math.Max(100, Math.Min(400, _resizeStartWidth + delta));
            PaletteWidth = newWidth;
        }
        
        InvokeAsync(StateHasChanged);
    }

    /// <summary>
    /// Called from JavaScript when mouse is released after resize
    /// </summary>
    [JSInvokable]
    public void OnPanelResizeEnd(string panel)
    {
        if (panel == "sidebar")
        {
            _isResizingSidebar = false;
            
            // Close sidebar if dragged too small - translated from sidebarSeparator.closing
            if (SidebarWidth < 150)
            {
                SidebarClosed = true;
                SidebarWidth = 315; // Reset to default
            }
            
            State.Events.Emit("sidebar:resize", null);
        }
        else if (panel == "palette")
        {
            _isResizingPalette = false;
        }
        
        _dotNetRef?.Dispose();
        _dotNetRef = null;
        
        InvokeAsync(StateHasChanged);
    }

    public async ValueTask DisposeAsync()
    {
        // Cleanup subscriptions
        foreach (var sub in _subscriptions)
        {
            sub.Dispose();
        }
        _subscriptions.Clear();

        // Cleanup DotNetObjectReference
        _dotNetRef?.Dispose();
        _dotNetRef = null;

        // Disconnect comms
        await Comms.DisconnectAsync();
    }
}
