@* Syncfusion Blazor ListView Component Wrapper *@
@* Replaces custom editableList with Syncfusion ListView *@

@typeparam TItem

<div class="red-ui-editableList @Class">
    @if (!string.IsNullOrEmpty(Header) || Addable)
    {
        <div class="red-ui-editableList-header">
            @if (!string.IsNullOrEmpty(Header))
            {
                <span class="red-ui-editableList-header-text">@Header</span>
            }
            @if (Addable)
            {
                <SfButton CssClass="red-ui-editableList-addBtn" IconCss="fa fa-plus" OnClick="@AddItem">
                    @AddLabel
                </SfButton>
            }
        </div>
    }
    <SfListView @ref="ListRef"
                DataSource="@Items"
                TValue="TItem"
                ShowCheckBox="false"
                CssClass="red-ui-editableList-list">
        <ListViewFieldSettings TValue="TItem" Id="Id" Text="Text" />
        <ListViewTemplates TValue="TItem">
            <Template>
                @{
                    var item = context as TItem;
                }
                <div class="red-ui-editableList-item-container">
                    @if (Sortable)
                    {
                        <span class="red-ui-editableList-item-handle">
                            <i class="fa fa-bars"></i>
                        </span>
                    }
                    <div class="red-ui-editableList-item-content">
                        @if (ItemTemplate != null && item != null)
                        {
                            @ItemTemplate(item)
                        }
                    </div>
                    @if (Removable)
                    {
                        <SfButton CssClass="red-ui-editableList-item-remove" 
                                  IconCss="fa fa-times" 
                                  OnClick="@(() => RemoveItem(item!))">
                        </SfButton>
                    }
                </div>
            </Template>
        </ListViewTemplates>
    </SfListView>
    @if (Items == null || !Items.Any())
    {
        <div class="red-ui-editableList-empty">@EmptyText</div>
    }
</div>

<style>
    .red-ui-editableList {
        border: 1px solid #ddd;
        border-radius: 3px;
        background: white;
    }
    .red-ui-editableList-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 10px;
        background: #f5f5f5;
        border-bottom: 1px solid #ddd;
    }
    .red-ui-editableList-header-text {
        font-weight: 500;
    }
    .red-ui-editableList-item-container {
        display: flex;
        align-items: center;
        padding: 8px;
    }
    .red-ui-editableList-item-handle {
        cursor: move;
        margin-right: 8px;
        color: #999;
    }
    .red-ui-editableList-item-content {
        flex: 1;
    }
    .red-ui-editableList-empty {
        padding: 20px;
        text-align: center;
        color: #999;
    }
</style>

@code {
    [Parameter] public List<TItem>? Items { get; set; }
    [Parameter] public RenderFragment<TItem>? ItemTemplate { get; set; }
    [Parameter] public string? Class { get; set; }
    [Parameter] public string? Header { get; set; }
    [Parameter] public bool Addable { get; set; } = false;
    [Parameter] public bool Removable { get; set; } = false;
    [Parameter] public bool Sortable { get; set; } = false;
    [Parameter] public string AddLabel { get; set; } = "Add";
    [Parameter] public string EmptyText { get; set; } = "No items";
    [Parameter] public EventCallback<TItem> OnItemAdded { get; set; }
    [Parameter] public EventCallback<TItem> OnItemRemoved { get; set; }
    [Parameter] public EventCallback<(int oldIndex, int newIndex)> OnItemMoved { get; set; }

    private SfListView<TItem>? ListRef;

    private async Task AddItem()
    {
        await OnItemAdded.InvokeAsync();
    }

    private async Task RemoveItem(TItem item)
    {
        if (Items != null && Items.Contains(item))
        {
            Items.Remove(item);
            await OnItemRemoved.InvokeAsync(item);
            StateHasChanged();
        }
    }

    public void AddItemToList(TItem item)
    {
        if (Items == null)
        {
            Items = new List<TItem>();
        }
        Items.Add(item);
        StateHasChanged();
    }

    public void Clear()
    {
        Items?.Clear();
        StateHasChanged();
    }
}
