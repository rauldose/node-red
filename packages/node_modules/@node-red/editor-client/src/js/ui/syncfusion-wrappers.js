/**
 * Copyright OpenJS Foundation and other contributors, https://openjsf.org/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

/**
 * Syncfusion component wrappers to replace jQuery UI components
 * These wrappers maintain the existing jQuery-style API for compatibility
 */

RED.syncfusion = (function() {
    
    // Dialog wrapper to replace jQuery UI dialog
    function createDialog(element, options) {
        options = options || {};
        
        var $element = $(element);
        var dialogObj = null;
        
        // Map jQuery UI dialog options to Syncfusion Dialog options
        var syncfusionOptions = {
            target: options.target || document.body,
            width: options.width || 'auto',
            height: options.height || 'auto',
            isModal: options.modal !== false,
            closeOnEscape: options.closeOnEscape !== false,
            visible: options.autoOpen !== false,
            showCloseIcon: options.closeText !== false,
            animationSettings: { effect: 'Fade', duration: 300 },
            position: options.position ? { X: options.position[0], Y: options.position[1] } : undefined,
            beforeOpen: options.beforeOpen || options.open,
            open: options.open,
            beforeClose: options.beforeClose,
            close: options.close,
            buttons: []
        };
        
        // Handle title
        if (options.title) {
            syncfusionOptions.header = options.title;
        }
        
        // Handle buttons
        if (options.buttons) {
            var buttonArray = Array.isArray(options.buttons) ? options.buttons : 
                             Object.keys(options.buttons).map(key => ({
                                 text: key,
                                 click: options.buttons[key]
                             }));
            
            syncfusionOptions.buttons = buttonArray.map(btn => ({
                buttonModel: {
                    content: btn.text,
                    cssClass: btn.class || '',
                    isPrimary: btn.class === 'primary'
                },
                click: function() {
                    if (btn.click) {
                        btn.click.call($element[0]);
                    }
                }
            }));
        }
        
        // Store the element content
        var content = $element.html();
        syncfusionOptions.content = content;
        
        // Create wrapper if needed
        if (!$element.hasClass('e-dialog')) {
            $element.addClass('e-dialog-wrapper');
        }
        
        // Create the Syncfusion Dialog
        if (typeof ej !== 'undefined' && ej.popups && ej.popups.Dialog) {
            dialogObj = new ej.popups.Dialog(syncfusionOptions);
            dialogObj.appendTo(element);
        } else {
            // Fallback: keep basic jQuery UI behavior if Syncfusion not loaded
            console.warn('Syncfusion Dialog not available, using fallback');
            return createDialogFallback(element, options);
        }
        
        // Store dialog instance on element
        $element.data('syncfusion-dialog', dialogObj);
        
        return dialogObj;
    }
    
    // Fallback to basic modal behavior if Syncfusion isn't available
    function createDialogFallback(element, options) {
        var $element = $(element);
        
        // Basic modal implementation
        var modal = {
            open: function() {
                $element.show();
                if (options.open) options.open.call($element[0]);
            },
            close: function() {
                $element.hide();
                if (options.close) options.close.call($element[0]);
            },
            destroy: function() {
                $element.remove();
            },
            option: function(key, value) {
                if (value !== undefined) {
                    options[key] = value;
                    return this;
                }
                return options[key];
            }
        };
        
        $element.data('dialog-fallback', modal);
        return modal;
    }
    
    // Button wrapper to replace jQuery UI button
    function createButton(element, options) {
        options = options || {};
        var $element = $(element);
        
        // For simple button, just add classes and handle enable/disable
        var buttonApi = {
            enable: function() {
                $element.prop('disabled', false).removeClass('disabled');
            },
            disable: function() {
                $element.prop('disabled', true).addClass('disabled');
            },
            option: function(key, value) {
                if (key === 'label' && value !== undefined) {
                    $element.text(value);
                }
            }
        };
        
        $element.data('button-api', buttonApi);
        
        // Apply initial options
        if (options.label) {
            $element.text(options.label);
        }
        if (options.disabled) {
            buttonApi.disable();
        }
        
        return buttonApi;
    }
    
    // Draggable wrapper to replace jQuery UI draggable
    function createDraggable(element, options) {
        options = options || {};
        var $element = $(element);
        
        var dragState = {
            isDragging: false,
            startX: 0,
            startY: 0,
            startLeft: 0,
            startTop: 0
        };
        
        var dragApi = {
            enable: function() {
                $element.css('cursor', 'move');
            },
            disable: function() {
                $element.css('cursor', '');
            },
            destroy: function() {
                $element.off('.draggable');
            }
        };
        
        // Handle element for dragging
        var $handle = options.handle ? $element.find(options.handle) : $element;
        
        $handle.on('mousedown.draggable', function(e) {
            if (options.disabled) return;
            
            dragState.isDragging = true;
            dragState.startX = e.pageX;
            dragState.startY = e.pageY;
            
            var offset = $element.position();
            dragState.startLeft = offset.left;
            dragState.startTop = offset.top;
            
            if (options.start) {
                var ui = {
                    position: { left: dragState.startLeft, top: dragState.startTop },
                    offset: offset
                };
                options.start.call($element[0], e, ui);
            }
            
            $(document).on('mousemove.draggable', handleMouseMove);
            $(document).on('mouseup.draggable', handleMouseUp);
            
            e.preventDefault();
        });
        
        function handleMouseMove(e) {
            if (!dragState.isDragging) return;
            
            var deltaX = e.pageX - dragState.startX;
            var deltaY = e.pageY - dragState.startY;
            
            var newLeft = dragState.startLeft + deltaX;
            var newTop = dragState.startTop + deltaY;
            
            // Apply axis constraint
            if (options.axis === 'x') {
                newTop = dragState.startTop;
            } else if (options.axis === 'y') {
                newLeft = dragState.startLeft;
            }
            
            var ui = {
                position: { left: newLeft, top: newTop },
                offset: { left: newLeft, top: newTop }
            };
            
            if (options.drag) {
                options.drag.call($element[0], e, ui);
            }
            
            $element.css({
                left: ui.position.left + 'px',
                top: ui.position.top + 'px'
            });
        }
        
        function handleMouseUp(e) {
            if (!dragState.isDragging) return;
            
            dragState.isDragging = false;
            
            if (options.stop) {
                var ui = {
                    position: $element.position(),
                    offset: $element.offset()
                };
                options.stop.call($element[0], e, ui);
            }
            
            $(document).off('.draggable');
        }
        
        $element.data('draggable-api', dragApi);
        return dragApi;
    }
    
    return {
        dialog: createDialog,
        button: createButton,
        draggable: createDraggable
    };
    
})();

// Extend jQuery to support Syncfusion wrappers with jQuery UI-compatible API
(function($) {
    var originalDialog = $.fn.dialog;
    var originalButton = $.fn.button;
    var originalDraggable = $.fn.draggable;
    
    $.fn.dialog = function(options) {
        if (typeof options === 'string') {
            // Handle method calls
            var method = options;
            var args = Array.prototype.slice.call(arguments, 1);
            
            return this.each(function() {
                var $this = $(this);
                var instance = $this.data('syncfusion-dialog') || $this.data('dialog-fallback');
                
                if (instance) {
                    switch(method) {
                        case 'open':
                            if (instance.show) instance.show();
                            else if (instance.open) instance.open();
                            break;
                        case 'close':
                            if (instance.hide) instance.hide();
                            else if (instance.close) instance.close();
                            break;
                        case 'destroy':
                            if (instance.destroy) instance.destroy();
                            break;
                        case 'option':
                            if (instance.option) return instance.option(args[0], args[1]);
                            break;
                    }
                }
            });
        } else {
            // Initialize dialog
            return this.each(function() {
                RED.syncfusion.dialog(this, options);
            });
        }
    };
    
    $.fn.button = function(options) {
        if (typeof options === 'string') {
            var method = options;
            var args = Array.prototype.slice.call(arguments, 1);
            
            return this.each(function() {
                var $this = $(this);
                var instance = $this.data('button-api');
                
                if (instance) {
                    switch(method) {
                        case 'enable':
                            instance.enable();
                            break;
                        case 'disable':
                            instance.disable();
                            break;
                        case 'option':
                            instance.option(args[0], args[1]);
                            break;
                    }
                }
            });
        } else {
            return this.each(function() {
                RED.syncfusion.button(this, options);
            });
        }
    };
    
    $.fn.draggable = function(options) {
        if (typeof options === 'string') {
            var method = options;
            
            return this.each(function() {
                var $this = $(this);
                var instance = $this.data('draggable-api');
                
                if (instance) {
                    switch(method) {
                        case 'enable':
                            instance.enable();
                            break;
                        case 'disable':
                            instance.disable();
                            break;
                        case 'destroy':
                            instance.destroy();
                            break;
                    }
                }
            });
        } else {
            return this.each(function() {
                RED.syncfusion.draggable(this, options);
            });
        }
    };
    
})(jQuery);
